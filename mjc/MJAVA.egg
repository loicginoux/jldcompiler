------------------------------------------
-- PROJET 07-08 - micro java : grammaire LL(3)
-- au format EGG5
------------------------------------------
option auto= true;
option version = 0.0.1 ;
option k=3;

-- les attributs semantiques
inh source : MJAVASourceFile for PROGRAMME;

inh tds : TDS for  DEFCLASSE,EXTENSION, DEFS,DEF;

inh tdm : TDM for DEFCLASSE,EXTENSION,DEFS,DEF;
syn params : List<String> for PARFS,PARFSX;
syn param : String for PARF;

inh tdt : TDT for DEFCLASSE,EXTENSION,DEF,DEFS,PARFSX,PARFS,PARF;
syn tdts : List<TDT> for IMPORTS;

syn visibility : COUPLE<Integer,Boolean> for DEFQUAL;
inh visibilitySyn : COUPLE<Integer,Boolean> for DEF;

syn nom : String for TYPE;
-- les terminaux 

space separateur is  "[\r\n\t ]+";
space comm is  "\/\/[^\n]*\n";
sugar import is  "import";
sugar paro is  "\(";
sugar parf is  "\)";
sugar aco is  "\{";
sugar acf is  "\}";
sugar cro is  "\[";
sugar crf is  "\]";
sugar virg is  ",";
sugar pv is  "\;";
sugar pt is  "\.";
sugar affect is  "=";
sugar si is  "if";
sugar sinon is  "else";
sugar tantque is  "while";
sugar void is  "void";
sugar int is  "int";
sugar bool is  "boolean";
sugar classe is  "class";
sugar etend is  "extends";
sugar retour is  "return";
sugar nouveau is  "new";
sugar public is  "public";
sugar prive is  "private";
sugar protect is  "protected";
sugar static is  "static";
sugar nil is  "null";
sugar inf is  "\<";
sugar infeg is  "\<=";
sugar sup is  "\>";
sugar supeg is  "\>=";
sugar eg is  "==";
sugar neg is  "\!=";
sugar plus is  "\+";
sugar moins is  "\-";
sugar ou is  "\|\|";
sugar mult is  "\*";
sugar div is  "\/";
sugar mod is  "\%" ; 
sugar et is  "\&\&";
sugar non is  "\!";
sugar vrai is  "true";
sugar faux is  "false";
sugar this is  "this";
sugar super is  "super";
term entier is  "[0-9]+";
term ident is  "[_A-Za-z][_0-9A-Za-z]*";


---------- REGLES DE PRODUCTION ----------------------------------------
PROGRAMME -> #init  IMPORTS #tds #tdt #tdm DEFCLASSE #gen #sauv ;
    global
       machine : AbstractMachine;
       tds:TDS;
       tdt:TDT;
       tdm:TDM;
   
    #init {
        local
        do
           machine := PROGRAMME^source.getMachine();
        end
    }
    
    #tds {
        do
            tds := new TDS();
            DEFCLASSE^tds := tds;
        end
    }
    #tdt{
    do
        tdt := new TDT("anonyme",IMPORTS^tdts);
        DEFCLASSE^tdt := tdt;
    end
    }
    #tdm{
    do
        tdm := new TDM();
        DEFCLASSE^tdm := tdm;
    end
    }

    #gen {
        do
          write ";TDS : " + tds;
          write "\n\n;TDT : "+tdt+"\n";
           write "\n\n;TDM : "+tdm+"\n";
          call machine.writeCode(PROGRAMME^source.getFileName(), "");
        end
    }
    
    #sauv{
    local
        fac:Factory;
    do
        fac := new Factory();
        call fac.persister(tds,tdt.getClassname()+".tds");
        call fac.persister(tdt,tdt.getClassname()+".tdt");
        call fac.persister(tdm,tdt.getClassname()+".tdm");
    end
    }

IMPORTS -> #tdts;
#tdts{
do
    IMPORTS^tdts := new Vector<TDT>();
end
}
IMPORTS -> import ident pv IMPORTS #tdts;
#tdts{
local 
    fac:Factory;
    tdt:TDT;
    tdts:List<TDT>;
do
    fac := new Factory();
    tdt := fac.chargerTDT(ident^txt);
    if tdt=nil then
        error(B_02,ident^txt);
    end   
    write "\ntdtimport:"+tdt+"\n"; 
    tdts := IMPORTS1^tdts;
    if tdts.contains(tdt) & tdt/=nil then
        warning(B_01,ident^txt);
        IMPORTS^tdts := tdts;
    else
        call tdts.add(tdt);
        IMPORTS^tdts := tdts;
    end
end
}
-- definition d'une classe
DEFCLASSE -> classe ident #tdt #tdm EXTENSION aco DEFS acf ;

#tdt {
local 
    type:Type;
do
    type := DEFCLASSE^tdt.chercherLocalement(ident^txt);
    if type=nil then
        call DEFCLASSE^tdt.setClassname(ident^txt);
    else
        error(B_03,ident^txt); --redefinition d'une classe importe
    end      
    EXTENSION^tdt := DEFCLASSE^tdt; --auto par egg
end
}

#tdm{
do
    call DEFCLASSE^tdm.setClassname(ident^txt);
end
}
    
-- heritage
EXTENSION -> etend ident #tdt #tds #tdm;
#tdt{
local
    type:Type;
    monType:Type;
do
    type:=EXTENSION^tdt.chercherLocalement(ident^txt);
    if type/=nil then
        monType := EXTENSION^tdt.getMonType();
        call monType.setClassExtends(ident^txt);
        call monType.setTaille(1); --taille du pointeur super
    else
        error(B_04,ident^txt);
    end
end
}

#tds{
local
    fac:Factory;
    i:INFO;
do
    fac := new Factory();
    call  EXTENSION^tds.setParente(fac.chargerTDS(ident^txt));
    i := new INFO();
    call i.setDep(0); -- plus tard
    call i.setStatique(false);
    call i.setVisibility(1); -- le super est private
    call i.setType(ident^txt);
    call EXTENSION^tds.inserer("super",i);
end
}

#tdm{
local
    fac:Factory;
do
    fac := new Factory();
    call  EXTENSION^tdm.setParente(fac.chargerTDM(ident^txt));
end
}

EXTENSION -> ;
-- les attributs
DEFS ->   ;
DEFS ->  DEFQUAL #tdsVis DEF DEFS   ;
#tdsVis{
do
    DEF^visibilitySyn := DEFQUAL^visibility;
end
}
-- public, private, protected, static
DEFQUAL -> #visibility;

    #visibility {
        do
            DEFQUAL^visibility := new COUPLE(-1, false); -- penser a le mettre public apres le DEFQUAL si toujours -1
        end
    }
    
DEFQUAL -> public DEFQUAL #visibility;

    #visibility {
        do
            if DEFQUAL1^visibility.getGauche() = -1 then
                DEFQUAL^visibility := new COUPLE(0, DEFQUAL1^visibility.getDroite());
            else
                error(B_00,"public");
            end
        end
    }
    
DEFQUAL -> prive DEFQUAL #visibility;

    #visibility {
        do
            if DEFQUAL1^visibility.getGauche() = -1 then
                DEFQUAL^visibility := new COUPLE(1, DEFQUAL1^visibility.getDroite());
            else
                error(B_00,"private");
            end
        end
    }
    
DEFQUAL -> protect DEFQUAL #visibility;

    #visibility {
        do
            if DEFQUAL1^visibility.getGauche() = -1 then
                DEFQUAL^visibility := new COUPLE(2, DEFQUAL1^visibility.getDroite());
            else
                error(B_00,"protected");
            end
        end
    }
    
DEFQUAL -> static DEFQUAL #visibility;

    #visibility {
        do
            if !DEFQUAL1^visibility.getDroite() then
                DEFQUAL^visibility := new COUPLE(DEFQUAL1^visibility.getGauche(), true);
            else
                error(B_00,"static");
            end
        end
    }
-- attribut
DEF ->  TYPE ident pv #tdt #tds ;
#tdt{
local 
    type:Type;
do
   type := DEF^tdt.chercherLocalement(TYPE^nom);
   if type=nil then
        error(B_04,TYPE^nom);
   else
        type := DEF^tdt.getMonType();
        call type.setTaille(type.getTaille()+1); --reflechir pour le statique
   end
   
end
}

#tds{
local
    i:INFO;
do
    i := DEF^tds.chercherLocalement(ident^txt);
    if i=nil then
        i := new INFO();
        call i.setDep(0); -- plus tard
        call i.setStatique(DEF^visibilitySyn.getDroite());
        call i.setVisibility(DEF^visibilitySyn.getGauche());
        call i.setType(TYPE^nom);
        call DEF^tds.inserer(ident^txt,i);
    else
        error(B_05,ident^txt);
    end
end
}

-- methode (fonction)
DEF ->  TYPE ident paro PARFS parf #tdt #tdm BLOC  ;
#tdt{
local
    t : Type;
do
    t := DEF^tdt.chercherLocalement(TYPE^nom);
    if t = nil then error(B_04, TYPE^nom);
    else
    end 
end
}
#tdm{
local
    s:Signature;
do
    s := new Signature();
    call s.ajouter(PARFS^params);
    call s.setStatique(DEF^visibilitySyn.getDroite());
    call s.setVisibility(DEF^visibilitySyn.getGauche());
    call s.setRetour(TYPE^nom);
    call DEF^tdm.inserer(ident^txt,s); -- verifier si la methode existe pas deja
end
}

-- methode (procedure)
DEF -> void ident  paro PARFS parf BLOC  ; 
-- constructeur
DEF -> ident  paro PARFS parf BLOC  ; 
-- classe interne
DEF -> DEFCLASSE ;
-- les types
TYPE-> int  #type;
#type{ do TYPE^nom := "int"; end }
TYPE-> bool #type;
#type{ do TYPE^nom := "bool"; end }
TYPE-> ident #type;
#type{ do TYPE^nom := ident^txt; end }
-- parametres de methodes
PARFS ->  #params;
#params{
do
    PARFS^params := new Vector<String>();
end
}
PARFS ->  PARF PARFSX #params ;
#params{
do
    call PARFSX^params.add(PARF^param);
    PARFS^params := PARFSX^params;
end
}
PARFSX -> #params  ;
#params{
do
    PARFSX^params := new Vector<String>();
end
}
PARFSX -> virg  PARF  PARFSX #params;
#params{
do
    call PARFSX1^params.add(PARF^param);
    PARFSX^params := PARFSX1^params;
end
}
PARF ->  TYPE ident #tdt #param  ;
#tdt{
local
    t : Type;
do
    t := PARF^tdt.chercherLocalement(TYPE^nom);
    if t = nil then  error(B_04, TYPE^nom);
    else
    end 
end
}
#param{
do
    PARF^param := TYPE^nom;
end
}
-- corps de methode et bloc d'instructions
BLOC ->  aco INSTS acf  ;
-- instructions
INSTS ->   ;
INSTS ->  INST INSTS  ;
-- declaration de variable locale avec ou sans init
INST->  TYPE ident AFFX pv ;
-- instruction expression
INST ->  E pv ;
-- bloc d'instructions
INST ->  BLOC  ;
-- conditionnelle
INST ->  si paro E parf BLOC SIX ;
SIX ->   sinon BLOC ;
SIX ->;
-- return
INST ->  retour E pv ;
-- tant que
INST ->  tantque paro E parf BLOC ;
-- les expressions
E ->  ER AFFX ;
-- affectation
AFFX ->  affect ER  ;
AFFX -> ;
-- relation
ER ->   ES ERX ;
ES ->  T ESX ;
ERX ->  OPREL ES ;
ERX -> ;
OPREL -> inf ;
OPREL -> infeg ;
OPREL -> sup ;
OPREL -> supeg ;
OPREL -> eg ;
OPREL -> neg ;
-- addition, ...
ESX ->   OPADD T ESX ;
ESX ->;
OPADD -> plus ;
OPADD -> moins ;
OPADD -> ou ;
T ->  F TX ;
-- multiplication, ...
TX ->   OPMUL F TX ;
TX -> ;
OPMUL -> mult ;
OPMUL -> div ;
OPMUL -> mod ;
OPMUL -> et ;
-- expressions de base
F -> entier  ;
F -> vrai  ;
F -> faux  ;
-- unaire
F ->  OPUN F ;
OPUN -> plus;
OPUN -> moins;
OPUN -> non;
-- null
F -> nil  ;
F ->  paro E parf ;
-- new
F -> nouveau  TYPE paro ARGS parf  ;
-- this 
F -> this Q ;
-- appel super 
F ->  super Q ;
-- acces variable ou methode 
F ->  ident Q ;
-- Q = qualificateur de variable
Q ->  ;
-- acces attribut
Q ->  pt ident  Q ;
-- arguments d'appel de methode
Q ->  paro ARGS parf Q ;
ARGS ->  E ARGSX  ;
ARGS -> ;
ARGSX ->   virg E ARGSX  ;
ARGSX -> ;

end
