------------------------------------------
-- PROJET 07-08 - micro java : grammaire LL(3)
-- au format EGG5
------------------------------------------
option auto= true;
option version = 0.0.1 ;
option k=3;

-- les attributs semantiques
inh source : MJAVASourceFile for PROGRAMME;

inh tds : TDS for IMPORTS, DEFCLASSE, DEF, DEFS;

inh tdt : TDT for DEFCLASSE,EXTENSION,DEF,DEFS;
syn tdts : List<TDT> for IMPORTS;

syn visibility : COUPLE<Integer,Boolean> for DEFQUAL;
-- les terminaux 

space separateur is  "[\r\n\t ]+";
space comm is  "\/\/[^\n]*\n";
sugar import is  "import";
sugar paro is  "\(";
sugar parf is  "\)";
sugar aco is  "\{";
sugar acf is  "\}";
sugar cro is  "\[";
sugar crf is  "\]";
sugar virg is  ",";
sugar pv is  "\;";
sugar pt is  "\.";
sugar affect is  "=";
sugar si is  "if";
sugar sinon is  "else";
sugar tantque is  "while";
sugar void is  "void";
sugar int is  "int";
sugar bool is  "boolean";
sugar classe is  "class";
sugar etend is  "extends";
sugar retour is  "return";
sugar nouveau is  "new";
sugar public is  "public";
sugar prive is  "private";
sugar protect is  "protected";
sugar static is  "static";
sugar nil is  "null";
sugar inf is  "\<";
sugar infeg is  "\<=";
sugar sup is  "\>";
sugar supeg is  "\>=";
sugar eg is  "==";
sugar neg is  "\!=";
sugar plus is  "\+";
sugar moins is  "\-";
sugar ou is  "\|\|";
sugar mult is  "\*";
sugar div is  "\/";
sugar mod is  "\%" ; 
sugar et is  "\&\&";
sugar non is  "\!";
sugar vrai is  "true";
sugar faux is  "false";
sugar this is  "this";
sugar super is  "super";
term entier is  "[0-9]+";
term ident is  "[_A-Za-z][_0-9A-Za-z]*";


---------- REGLES DE PRODUCTION ----------------------------------------
PROGRAMME -> #init #tds IMPORTS #tdt DEFCLASSE #gen ;
    global
       machine : AbstractMachine;
       tds:TDS;
       tdt:TDT;
   
    #init {
        local
        do
           machine := PROGRAMME^source.getMachine();
        end
    }
    
    #tds {
        do
            tds := new TDS();
            IMPORTS^tds := tds;
            DEFCLASSE^tds := tds;
        end
    }
    #tdt{
    do
        tdt := new TDT("anonyme",IMPORTS^tdts);
        DEFCLASSE^tdt := tdt;
    end
    }

    #gen {
        do
          write ";TDS : " + tds;
          write "\n\n;TDT : "+tdt+"\n";
          call machine.writeCode(PROGRAMME^source.getFileName(), "");
        end
    }

IMPORTS -> #tdts;
#tdts{
do
    IMPORTS^tdts := new Vector<TDT>();
end
}
IMPORTS -> import ident pv IMPORTS #tdts;
#tdts{
local 
    fac:Factory;
    tdt:TDT;
    tdts:List<TDT>;
do
    fac := new Factory();
    tdt := fac.chargerTDT(ident^txt);
    if tdt=nil then
        error(B_02,ident^txt);
    end   
    --write "\ntdtimport:"+tdt+"\n"; 
    tdts := IMPORTS1^tdts;
    if tdts.contains(tdt) & tdt/=nil then
        warning(B_01,ident^txt);
        IMPORTS^tdts := tdts;
    else
        call tdts.add(tdt);
        IMPORTS^tdts := tdts;
    end
end
}
-- definition d'une classe
DEFCLASSE -> classe ident #tdt EXTENSION aco DEFS acf #sauv;

#tdt {
local 
    type:Type;
do
    type := DEFCLASSE^tdt.chercherLocalement(ident^txt);
    if type=nil then
        call DEFCLASSE^tdt.setClassname(ident^txt);
    else
        error(B_03,ident^txt); --redefinition d'une classe importe
    end      
    EXTENSION^tdt := DEFCLASSE^tdt; --auto par egg
end
}
    
    #sauv{
    local
        fac:Factory;
    do
        fac := new Factory();
        call fac.persister(DEFCLASSE^tds,ident^txt+".tds");
        call fac.persister(DEFCLASSE^tdt,ident^txt+".tdt");
    end
    }
-- heritage
EXTENSION -> etend ident #tdt;
#tdt{
local
    type:Type;
    monType:Type;
do
    type:=EXTENSION^tdt.chercherLocalement(ident^txt);
    if type/=nil then
        monType := EXTENSION^tdt.getMonType();
        call monType.setClassExtends(ident^txt);
        call monType.setTaille(type.getTaille()); --TODO reflechir
    else
        error(B_04,ident^txt);
    end
end
}
EXTENSION -> ;
-- les attributs
DEFS ->   ;
DEFS ->  DEFQUAL DEF DEFS   ;
-- public, private, protected, static
DEFQUAL -> #visibility;

    #visibility {
        do
            DEFQUAL^visibility := new COUPLE(-1, false); -- penser a le mettre public apres le DEFQUAL si toujours -1
        end
    }
    
DEFQUAL -> public DEFQUAL #visibility;

    #visibility {
        do
            if DEFQUAL1^visibility.getGauche() = -1 then
                DEFQUAL^visibility := new COUPLE(0, DEFQUAL1^visibility.getDroite());
            else
                error(B_00,"public");
            end
        end
    }
    
DEFQUAL -> prive DEFQUAL #visibility;

    #visibility {
        do
            if DEFQUAL1^visibility.getGauche() = -1 then
                DEFQUAL^visibility := new COUPLE(1, DEFQUAL1^visibility.getDroite());
            else
                error(B_00,"private");
            end
        end
    }
    
DEFQUAL -> protect DEFQUAL #visibility;

    #visibility {
        do
            if DEFQUAL1^visibility.getGauche() = -1 then
                DEFQUAL^visibility := new COUPLE(2, DEFQUAL1^visibility.getDroite());
            else
                error(B_00,"protected");
            end
        end
    }
    
DEFQUAL -> static DEFQUAL #visibility;

    #visibility {
        do
            if !DEFQUAL1^visibility.getDroite() then
                DEFQUAL^visibility := new COUPLE(DEFQUAL1^visibility.getGauche(), true);
            else
                error(B_00,"static");
            end
        end
    }
-- attribut
DEF ->  TYPE ident pv  ;
-- methode (fonction)
DEF ->  TYPE ident paro PARFS parf BLOC  ;
-- methode (procedure)
DEF -> void ident  paro PARFS parf BLOC  ; 
-- constructeur
DEF -> ident  paro PARFS parf BLOC  ; 
-- classe interne
DEF -> DEFCLASSE ;
-- les types
TYPE-> int  ;
TYPE-> bool ;
TYPE-> ident ;
-- parametres de methodes
PARFS ->  ;
PARFS ->  PARF PARFSX ;
PARFSX ->  ;
PARFSX -> virg  PARF  PARFSX ;
PARF ->  TYPE ident  ;
-- corps de methode et bloc d'instructions
BLOC ->  aco INSTS acf  ;
-- instructions
INSTS ->   ;
INSTS ->  INST INSTS  ;
-- declaration de variable locale avec ou sans init
INST->  TYPE ident AFFX pv ;
-- instruction expression
INST ->  E pv ;
-- bloc d'instructions
INST ->  BLOC  ;
-- conditionnelle
INST ->  si paro E parf BLOC SIX ;
SIX ->   sinon BLOC ;
SIX ->;
-- return
INST ->  retour E pv ;
-- tant que
INST ->  tantque paro E parf BLOC ;
-- les expressions
E ->  ER AFFX ;
-- affectation
AFFX ->  affect ER  ;
AFFX -> ;
-- relation
ER ->   ES ERX ;
ES ->  T ESX ;
ERX ->  OPREL ES ;
ERX -> ;
OPREL -> inf ;
OPREL -> infeg ;
OPREL -> sup ;
OPREL -> supeg ;
OPREL -> eg ;
OPREL -> neg ;
-- addition, ...
ESX ->   OPADD T ESX ;
ESX ->;
OPADD -> plus ;
OPADD -> moins ;
OPADD -> ou ;
T ->  F TX ;
-- multiplication, ...
TX ->   OPMUL F TX ;
TX -> ;
OPMUL -> mult ;
OPMUL -> div ;
OPMUL -> mod ;
OPMUL -> et ;
-- expressions de base
F -> entier  ;
F -> vrai  ;
F -> faux  ;
-- unaire
F ->  OPUN F ;
OPUN -> plus;
OPUN -> moins;
OPUN -> non;
-- null
F -> nil  ;
F ->  paro E parf ;
-- new
F -> nouveau  TYPE paro ARGS parf  ;
-- this 
F -> this Q ;
-- appel super 
F ->  super Q ;
-- acces variable ou methode 
F ->  ident Q ;
-- Q = qualificateur de variable
Q ->  ;
-- acces attribut
Q ->  pt ident  Q ;
-- arguments d'appel de methode
Q ->  paro ARGS parf Q ;
ARGS ->  E ARGSX  ;
ARGS -> ;
ARGSX ->   virg E ARGSX  ;
ARGSX -> ;

end
