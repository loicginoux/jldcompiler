------------------------------------------
-- PROJET 07-08 - micro java : grammaire LL(3)
-- au format EGG5
------------------------------------------
option auto= true;
option version = 0.0.1 ;
option k=3;

-- les attributs semantiques ----------------------------------------------------------------------
inh source : MJAVASourceFile for PROGRAMME;

inh tds : TDS for  DEFCLASSE, EXTENSION, DEFS, DEF,BLOC,INSTS,INST,SIX,PARFSX, PARFS, PARF;

inh tdm : TDM for DEFCLASSE, EXTENSION, DEFS, DEF, INST, INSTS, BLOC,SIX;
syn params : List<String> for PARFS, PARFSX;
syn param : String for PARF;

inh tdt : TDT for DEFCLASSE, EXTENSION, DEF, DEFS, PARFSX, PARFS, PARF, INSTS, INST, BLOC, SIX;
syn tdts : List<TDT> for IMPORTS;

syn visibility : COUPLE<Integer,Boolean> for DEFQUAL;
inh visibilitySyn : COUPLE<Integer,Boolean> for DEF;

syn nom : String for TYPE;

syn code : String for IMPORTS, DEFCLASSE, DEFS, DEF, BLOC, INSTS, INST, AFFX, E, SIX, F, OPUN,
                        OPREL, OPADD, OPMUL, ESX, T, TX, ER, ES, ERX, Q, ARGS, ARGSX;
inh machine : AbstractMachine for PROGRAMME, DEFCLASSE, DEFS, DEF, BLOC, INSTS, INST, SIX, E,
                                    ARGS, F, AFFX, ARGSX, Q, T, TX, ES, ESX, ER, ERX, OPUN,
                                    OPREL, OPADD, OPMUL;
inh nomMethode : String for INST, INSTS, BLOC, SIX;

-- les terminaux ----------------------------------------------------------------------------------

space separateur is  "[\r\n\t ]+";
space comm is  "\/\/[^\n]*\n";
sugar import is  "import";
sugar paro is  "\(";
sugar parf is  "\)";
sugar aco is  "\{";
sugar acf is  "\}";
sugar cro is  "\[";
sugar crf is  "\]";
sugar virg is  ",";
sugar pv is  "\;";
sugar pt is  "\.";
sugar affect is  "=";
sugar si is  "if";
sugar sinon is  "else";
sugar tantque is  "while";
sugar void is  "void";
sugar int is  "int";
sugar bool is  "boolean";
sugar classe is  "class";
sugar etend is  "extends";
sugar retour is  "return";
sugar nouveau is  "new";
sugar public is  "public";
sugar prive is  "private";
sugar protect is  "protected";
sugar static is  "static";
sugar nil is  "null";
sugar inf is  "\<";
sugar infeg is  "\<=";
sugar sup is  "\>";
sugar supeg is  "\>=";
sugar eg is  "==";
sugar neg is  "\!=";
sugar plus is  "\+";
sugar moins is  "\-";
sugar ou is  "\|\|";
sugar mult is  "\*";
sugar div is  "\/";
sugar mod is  "\%" ; 
sugar et is  "\&\&";
sugar non is  "\!";
sugar vrai is  "true";
sugar faux is  "false";
sugar this is  "this";
sugar super is  "super";
term entier is  "[0-9]+";
term ident is  "[_A-Za-z][_0-9A-Za-z]*";


---------- REGLES DE PRODUCTION -------------------------------------------------------------------
PROGRAMME -> #init  IMPORTS #tds #tdt #tdm DEFCLASSE #gen #sauv ;
    global
       machine : AbstractMachine;
       tds : TDS;
       tdt : TDT;
       tdm : TDM;
       langage : String;
    #init {
        local
            fac : Factory;
        do
           machine := PROGRAMME^source.getMachine();
           DEFCLASSE^machine := machine;
           langage := machine.getSuffixe();
           fac := new Factory();
           call fac.setLangage(langage);
        end
    }
    #tds {
        do
            tds := new TDS();
            DEFCLASSE^tds := tds;
        end
    }
    #tdt {
	    do
	        tdt := new TDT("anonyme",IMPORTS^tdts);
	        DEFCLASSE^tdt := tdt;
	    end
    }
    #tdm {
	    do
	        tdm := new TDM();
	        DEFCLASSE^tdm := tdm;
	    end
    }
    #gen {
        do
          write ";TDS : " + tds;
          write "\n\n;TDT : " + tdt + "\n";
          write "\n\n;TDM : " + tdm + "\n";
          call machine.writeCode(PROGRAMME^source.getFileName(), IMPORTS^code + DEFCLASSE^code);
          write "fin gen\n";
        end
    }
    #sauv {
	    local
	        fac : Factory;
	    do
	        fac := new Factory();
	        call fac.persister(tds, tdt.getClassname() + ".tds");
	        call fac.persister(tdt, tdt.getClassname() + ".tdt");
	        call fac.persister(tdm, tdt.getClassname() + ".tdm");
	        call fac.persister(IMPORTS^code + DEFCLASSE^code, tdt.getClassname() + "_code." + langage);
	        write "fin sauv\n";
	    end
    }

IMPORTS -> #tdts #code;
	#tdts {
		do
		    IMPORTS^tdts := new Vector<TDT>();
		end
	}
	#code {
		do
		    IMPORTS^code := "";
		end
	}

IMPORTS -> import ident pv IMPORTS #tdts #code;
	#tdts {
		local 
		    fac : Factory;
		    tdt : TDT;
		    tdts : List<TDT>;
		do
		    fac := new Factory();
		    tdt := fac.chargerTDT(ident^txt);
		    if tdt = nil then
		        error(B_02, ident^txt);
		    end   
		  --  write "\ntdtimport:" + tdt + "\n"; 
		    tdts := IMPORTS1^tdts;
		    if tdts.contains(tdt) & tdt /= nil then
		        warning(B_01, ident^txt);
		        IMPORTS^tdts := tdts;
		    else
		        call tdts.add(tdt);
		        IMPORTS^tdts := tdts;
		    end
		end
	}
	#code {
		local 
		    fac : Factory;
		    importCode : String;
		do
		    fac := new Factory();
		    importCode := fac.chargerCode(ident^txt + "_code");
		    IMPORTS^code := ";import "+ ident^txt + "\n" + importCode + "\n" + IMPORTS1^code;
		end
	}

-- definition d'une classe ------------------------------------------------------------------------
DEFCLASSE -> classe ident #tdt #tdm EXTENSION aco DEFS acf #code ;
	#tdt {
		local 
		    type : Type;
		do
		    type := DEFCLASSE^tdt.chercherLocalement(ident^txt);
		    if type = nil then
		        call DEFCLASSE^tdt.setClassname(ident^txt);
		    else
		        error(B_03, ident^txt); --redefinition d'une classe importe
		    end      
		    EXTENSION^tdt := DEFCLASSE^tdt; --auto par egg
		end
	}
	#tdm {
		do
		    call DEFCLASSE^tdm.setClassname(ident^txt);
		end
	}
	#code {
		do
		    DEFCLASSE^code := ";classe "+ ident^txt + "\n" + DEFS^code;
		end
	}
    
-- heritage
EXTENSION -> etend ident #tdt #tds #tdm ; -- le code est deja insere dans les imports
	#tdt {
		local
		    type : Type;
		    monType : Type;
		do
		    type := EXTENSION^tdt.chercherLocalement(ident^txt);
		    if type /= nil then
		        monType := EXTENSION^tdt.getMonType();
		        call monType.setClassExtends(ident^txt);
		        call monType.setTaille(1); --taille du pointeur super
		    else
		        error(B_04, ident^txt);
		    end
		end
	}
	#tds {
		local
		    fac : Factory;
		    i : INFO;
		do
		    fac := new Factory();
		    call EXTENSION^tds.setParente(fac.chargerTDS(ident^txt));
		    i := new INFO();
		    call i.setDep(0); -- TODO plus tard
		    call i.setStatique(false);
		    call i.setVisibility(1); -- le super est private
		    call i.setType(ident^txt);
		    call EXTENSION^tds.inserer("super",i);
		end
	}
	#tdm {
		local
		    fac : Factory;
		do
		    fac := new Factory();
		    call  EXTENSION^tdm.setParente(fac.chargerTDM(ident^txt));
		end
	}

EXTENSION -> ;

-- les attributs ----------------------------------------------------------------------------------
DEFS ->  #code ;
	#code {
		do
		    DEFS^code := "";
		end
	}

DEFS ->  DEFQUAL #tdsVis DEF DEFS  #code ;
	#tdsVis {
		do
		    DEF^visibilitySyn := DEFQUAL^visibility;
		end
	}
	#code {
		do
		    DEFS^code := DEF^code + "\n" + DEFS1^code;
		end
	}

-- public, private, protected, static -------------------------------------------------------------
DEFQUAL -> #visibility;
    #visibility {
        do
            DEFQUAL^visibility := new COUPLE(-1, false); -- penser a le mettre public apres le DEFQUAL si toujours -1
        end
    }
    
DEFQUAL -> public DEFQUAL #visibility;
    #visibility {
        do
            if DEFQUAL1^visibility.getGauche() = -1 then
                DEFQUAL^visibility := new COUPLE(0, DEFQUAL1^visibility.getDroite());
            else
                error(B_00, "public");
            end
        end
    }
    
DEFQUAL -> prive DEFQUAL #visibility;
    #visibility {
        do
            if DEFQUAL1^visibility.getGauche() = -1 then
                DEFQUAL^visibility := new COUPLE(1, DEFQUAL1^visibility.getDroite());
            else
                error(B_00, "private");
            end
        end
    }
    
DEFQUAL -> protect DEFQUAL #visibility;
    #visibility {
        do
            if DEFQUAL1^visibility.getGauche() = -1 then
                DEFQUAL^visibility := new COUPLE(2, DEFQUAL1^visibility.getDroite());
            else
                error(B_00, "protected");
            end
        end
    }
    
DEFQUAL -> static DEFQUAL #visibility;
    #visibility {
        do
            if !DEFQUAL1^visibility.getDroite() then
                DEFQUAL^visibility := new COUPLE(DEFQUAL1^visibility.getGauche(), true);
            else
                error(B_00, "static");
            end
        end
    }
    
-- attribut ---------------------------------------------------------------------------------------
DEF ->  TYPE ident pv #tdt #tds #code ;
	#tdt {
		local 
		    type : Type;
		do
		   type := DEF^tdt.chercherLocalement(TYPE^nom);
		   if type = nil then
		        error(B_04,TYPE^nom);
		   else
		        type := DEF^tdt.getMonType();
		        call type.setTaille(type.getTaille() + 1); --reflechir pour le statique
		   end
		   
		end
	}
	#tds {
		local
		    i : INFO;
		do
		    i := DEF^tds.chercherLocalement(ident^txt);
		    if i = nil then
		        i := new INFO();
		        call i.setDep(0); -- TODO : plus tard
		        call i.setStatique(DEF^visibilitySyn.getDroite());
		        call i.setVisibility(DEF^visibilitySyn.getGauche());
		        call i.setType(TYPE^nom);
		        call DEF^tds.inserer(ident^txt, i);
		    else
		        error(B_05, ident^txt);
		    end
		end
	}
	#code {
		do
		    DEF^code := "";
		    -- on ne genere pas de declaration car la grammaire empeche
		    -- de declarer et d'initiliser en meme temps un attribut
		end
	}

-- methode (fonction) -----------------------------------------------------------------------------
DEF ->  TYPE ident paro #tds PARFS parf #tdt #tdm BLOC #code #debug;
    global
        tds:TDS;
	#tds {
	    local 
	        i:INFO;
	    do
	        tds := new TDS(DEF^tds);
	        PARFS^tds := tds;
	        i := new INFO();
	        call i.setType(DEF^tdt.getClassname());
	        call tds.inserer("this",i); --ajout du this 
	        
	        BLOC^tds := tds; --auto par egg
	    end
    }
    #tdt {
		local
		    t : Type;
		do
		    t := DEF^tdt.chercherLocalement(TYPE^nom);
		    if t = nil then error(B_04, TYPE^nom);
		    else
		    end 
		end
	}
	#tdm {
		local
		    s : Signature;
		    stemp : Signature;
		do
		    s := new Signature();
		    call s.ajouter(PARFS^params);
		    call s.setStatique(DEF^visibilitySyn.getDroite());
		    call s.setVisibility(DEF^visibilitySyn.getGauche());
		    call s.setRetour(TYPE^nom);

		    if (DEF^tdm.containsKey(ident^txt + "_" + s.getStringParams())) then --meme methode
		        error(B_06, ident^txt, s.toString());
		    else
		    end
		    call DEF^tdm.inserer(ident^txt + "_" + s.getStringParams(), s);
		    BLOC^nomMethode := ident^txt + "_" + s.getStringParams();
		end
	}
	#code {
		do
		    DEF^code := "\t;methode " + ident^txt + "\n" + BLOC^code;
		end
	}
    #debug {
	    do
	        write("tds de "+ident^txt+" : "+tds);
	    end
    }

-- methode (procedure) ----------------------------------------------------------------------------
DEF -> void ident  paro #tds PARFS parf #tdm  BLOC #code #debug;
    global
        tds : TDS;
        s : Signature;
    #tds {
	    local 
	        i:INFO;
	    do
	        tds := new TDS(DEF^tds);
	        PARFS^tds := tds;
	        i := new INFO();
	        call i.setType(DEF^tdt.getClassname());
	        call tds.inserer("this",i); --ajout du this 
	        
	        BLOC^tds := tds; --auto par egg
	    end
    }
	#tdm {
		local
		    stemp : Signature; 
		do
		    s := new Signature();
		    call s.ajouter(PARFS^params);
		    call s.setStatique(DEF^visibilitySyn.getDroite());
		    call s.setVisibility(DEF^visibilitySyn.getGauche());
		    call s.setRetour(nil);

		    if(DEF^tdm.containsKey(ident^txt + "_" + s.getStringParams())) then --meme methode
		        error(B_06, ident^txt, s.toString());
		    else
		    end
		    call DEF^tdm.inserer(ident^txt + "_" + s.getStringParams(), s);
		    BLOC^nomMethode := ident^txt + "_" + s.getStringParams();
		end
	}
	#code {
		do
		    DEF^code := "\t;methode " + ident^txt + "\n" + BLOC^code + 
                        DEF^machine.genReturn(ident^txt + "_" + s.getStringParams(), DEF^tdm);
            -- TODO  : return. quelle taille ?
		end
	}
    #debug {
	    do
	        write("tds de "+ident^txt+" : "+tds);
	    end
    }

-- constructeur -----------------------------------------------------------------------------------
DEF -> ident  paro #tds PARFS parf #tdm BLOC #code #debug ; 
    global
        tds : TDS;
        s : Signature;
    #tds {
	    local 
	        i:INFO;
	    do
	        tds := new TDS(DEF^tds);
	        PARFS^tds := tds;
	        i := new INFO();
	        call i.setType(DEF^tdt.getClassname());
	        call tds.inserer("this",i); --ajout du this 
	        
	        BLOC^tds := tds; --auto par egg
	    end
    }
	#tdm {
		local
		    stemp : Signature; 
		do
		    s := new Signature();
		    call s.ajouter(PARFS^params);
		    call s.setStatique(DEF^visibilitySyn.getDroite());
		    call s.setVisibility(DEF^visibilitySyn.getGauche());
		    call s.setRetour(DEF^tdt.getClassname());

		    if(DEF^tdm.containsKey(ident^txt + "_" + s.getStringParams())) then --meme cons
		        error(B_06, ident^txt, s.toString());
		    else
		    end
		    call DEF^tdm.inserer(ident^txt + "_" + s.getStringParams(), s);
		    BLOC^nomMethode := ident^txt + "_" + s.getStringParams();
		end
	}
	#code {
		do
		    DEF^code := "\t;constructeur " + ident^txt + "\n" + BLOC^code + 
                        DEF^machine.genReturn(ident^txt + "_" + s.getStringParams(), DEF^tdm);
		end
	}
    
    #debug {
	    do
	        write("tds de "+ident^txt+" : "+tds);
	    end
    }

-- classe interne ---------------------------------------------------------------------------------
DEF -> DEFCLASSE #code ;
	#code {
		do
		    DEF^code := DEFCLASSE^code;
		end
	}

-- les types --------------------------------------------------------------------------------------
TYPE-> int  #type;
    #type { do TYPE^nom := "int"; end }
    
TYPE-> bool #type;
    #type { do TYPE^nom := "bool"; end }
    
TYPE-> ident #type;
    #type { do TYPE^nom := ident^txt; end }
    
-- parametres de methodes -------------------------------------------------------------------------
PARFS ->  #params;
	#params {
		do
		    PARFS^params := new Vector<String>();
		end
	}

PARFS ->  PARF PARFSX #params ;
	#params {
		do
		    call PARFSX^params.add(PARF^param);
		    PARFS^params := PARFSX^params;
		end
	}

PARFSX -> #params  ;
	#params {
		do
		    PARFSX^params := new Vector<String>();
		end
	}

PARFSX -> virg  PARF  PARFSX #params ;
	#params {
		do
		    call PARFSX1^params.add(PARF^param);
		    PARFSX^params := PARFSX1^params;
		end
	}
    
PARF ->  TYPE ident #tdt #param #tds  ;
	#tdt {
		local
		    t : Type;
		do
		    t := PARF^tdt.chercherLocalement(TYPE^nom);
		    if t = nil then  error(B_04, TYPE^nom); --type inconnu ds les import
		    else
		    end 
		end
	}
	#param {
		do
		    PARF^param := TYPE^nom;
		end
	}
    #tds {
	    local 
	        i:INFO;
	    do
	        i := PARF^tds.chercherLocalement(ident^txt);
	        if i/=nil then
	            error(B_07,ident^txt);
	        else
	            i := new INFO();
	            call i.setType(TYPE^nom);
	            call PARF^tds.inserer(ident^txt,i);
	        end
	    end
    }

-- corps de methode et bloc d'instructions --------------------------------------------------------
BLOC ->  aco INSTS acf #code ;
	#code {
		do
		    BLOC^code := INSTS^code;
		end
	}

-- instructions -----------------------------------------------------------------------------------
INSTS ->  #code ;
	#code {
		do
		    INSTS^code := "";
		end
	}

INSTS ->  INST INSTS #code ;
	#code {
		do
		    INSTS^code := INST^code + "\n" + INSTS1^code;
		end
	}

-- declaration de variable locale avec ou sans init -----------------------------------------------
INST->  TYPE #tdt ident AFFX #tds pv #code ;
     #tdt {
        local
            t : Type;
        do
            t := INST^tdt.chercherLocalement(TYPE^nom);
            if t = nil then  error(B_04, TYPE^nom); --type inconnu ds les import
            else
            end 
        end
    }
	#code {
		do
		    INST^code := AFFX^code;
		end
	}
    
    #tds { --seulement apres l'affectation car on ne connait pas sa propre declaration !!!
	    local 
	        i:INFO;
	    do
	        
	        i := INST^tds.chercherLocalement(ident^txt);
	        if i /= nil then
	            error(B_08, ident^txt);
	        else
	            i := new INFO();
	            call i.setType(TYPE^nom);
	            call INST^tds.inserer(ident^txt, i);
	        end
	    end
    }

-- instruction expression -------------------------------------------------------------------------
INST ->  E pv #code ;
	#code {
		do
		    INST^code := E^code;
		end
	}

-- bloc d'instructions ----------------------------------------------------------------------------
INST -> #tds BLOC #code ;
    #tds {
	    do
	        BLOC^tds := new TDS(INST^tds);
	    end
    }
	#code {
		do
		    INST^code := BLOC^code;
		end
	}

-- conditionnelle ---------------------------------------------------------------------------------
INST ->  si paro E parf #tds BLOC SIX #code ;
    #tds {
	    do
	        BLOC^tds := new TDS(INST^tds);
	        SIX^tds := INST^tds ; --auto par egg
	    end
    }
	#code {
		do
		    INST^code := E^code + INST^machine.genCond(BLOC^code, SIX^code);
		end
	}
    

SIX ->   sinon #tds BLOC #code ;
    #tds {
	    do
	        BLOC^tds := new TDS(SIX^tds);
	    end
    }
	#code {
		do
		    SIX^code := BLOC^code;
		end
	}

SIX -> #code ;
	#code {
		do
		    SIX^code := "";
		end
	}

-- return -----------------------------------------------------------------------------------------
INST ->  retour E pv #code ;
	#code {
		do
		    INST^code := E^code + INST^machine.genReturn(INST^nomMethode, INST^tdm); -- XXX a verifier
		end
	}

-- tant que ---------------------------------------------------------------------------------------
INST ->  tantque paro E parf #tds BLOC #code ;
    #tds {
	    do
	        BLOC^tds := new TDS(INST^tds);
	    end
    }
	#code {
		do
		    INST^code := INST^machine.genWhile(E^code, BLOC^code);
		end
	}

-- les expressions --------------------------------------------------------------------------------
E ->  ER AFFX #code ;
	#code {
		do
		    E^code := ""; -- E^machine.genExpression(); -- TODO
		end
	}

-- affectation ------------------------------------------------------------------------------------
AFFX ->  affect ER #code ;
	#code {
		do
		    AFFX^code := ""; -- AFFX^machine.genValeur(); -- TODO
		end
	}

AFFX -> #code ;
	#code {
		do
		    AFFX^code := "";
		end
	}

-- relation ---------------------------------------------------------------------------------------
ER ->   ES ERX #code ;
    #code {
        do
          ER^code := ER^machine.genExprValeur(ES^code, ERX^code); -- XXX
        end
    }

ES ->  T ESX #code ;
    #code {
        do
            ES^code := ES^machine.genExprValeur(T^code, ESX^code); -- XXX
        end
    }

ERX ->  OPREL ES #code ;
    #code {
        do
            ERX^code := ERX^machine.genExprValeur(ES^code, OPREL^code); -- XXX
        end
    }

ERX -> #code ;
    #code {
        do
            ERX^code := "";
        end
    }

OPREL -> inf #code ;
    #code {
        do
          OPREL^code := OPREL^machine.genInf();
        end
    }

OPREL -> infeg #code ;
    #code {
        do
          OPREL^code := OPREL^machine.genInfEg();
        end
    }

OPREL -> sup #code ;
    #code {
        do
          OPREL^code := OPREL^machine.genSup();
        end
    }

OPREL -> supeg #code ;
    #code {
        do
          OPREL^code := OPREL^machine.genSupEg();
        end
    }

OPREL -> eg #code ;
    #code {
        do
          OPREL^code := OPREL^machine.genEg();
        end
    }

OPREL -> neg #code ;
    #code {
        do
          OPREL^code := OPREL^machine.genNEg();
        end
    }

-- addition, ... ----------------------------------------------------------------------------------
ESX ->   OPADD T ESX #code ;
    #code {
        do
          ESX^code := ESX^machine.genExprValeur(T^code, OPADD^code) + ESX1^code; -- XXX si T est une valeur ? ne pas faire le LOADI ?
        end
    }

ESX -> #code ;
    #code {
        do
          ESX^code := "";
        end
    }

OPADD -> plus #code ;
    #code {
        do
          OPADD^code := OPADD^machine.genPlus();
        end
    }

OPADD -> moins #code ;
    #code {
        do
          OPADD^code := OPADD^machine.genMoins();
        end
    }

OPADD -> ou #code ;
    #code {
        do
          OPADD^code := OPADD^machine.genOu();
        end
    }

T ->  F TX #code ;
    #code {
        do
          T^code := T^machine.genExprValeur(F^code, TX^code); -- XXX
        end
    }

-- multiplication, ... ----------------------------------------------------------------------------
TX ->   OPMUL F TX #code ;
    #code {
        do
          TX^code := TX^machine.genExprValeur(F^code, OPMUL^code) + TX1^code; -- XXX
        end
    }

TX -> #code ;
    #code {
        do
          TX^code := "";
        end
    }

OPMUL -> mult #code ;
    #code {
        do
          OPMUL^code := OPMUL^machine.genMult();
        end
    }

OPMUL -> div #code ;
    #code {
        do
          OPMUL^code := OPMUL^machine.genDiv();
        end
    }

OPMUL -> mod #code ;
    #code {
        do
          OPMUL^code := OPMUL^machine.genMod();
        end
    }

OPMUL -> et #code ;
    #code {
        do
          OPMUL^code := OPMUL^machine.genEt();
        end
    }


-- expressions de base ----------------------------------------------------------------------------
F -> entier #code ;
    #code {
        do
          F^code := F^machine.genInt(entier^txt);
        end
    }

F -> vrai #code ;
	#code {
		do
		  F^code := F^machine.genTrue();
		end
	}

F -> faux #code ;
    #code {
        do
          F^code := F^machine.genFalse();
        end
    }

-- unaire -----------------------------------------------------------------------------------------
F ->  OPUN F #code ;
    #code {
        do
          F^code := F^machine.genExprValeur(F1^code, OPUN^code); -- XXX
        end
    }
    
OPUN -> plus #code ;
    #code {
        do
          OPUN^code := OPUN^machine.genPlusInt(); -- XXX a verif
        end
    }
    
OPUN -> moins #code ;
    #code {
        do
          OPUN^code := OPUN^machine.genMoinsInt();
        end
    }
    
OPUN -> non #code ;
    #code {
        do
          OPUN^code := OPUN^machine.genNegation();
        end
    }
    
-- null -------------------------------------------------------------------------------------------
F -> nil #code ;
    #code {
        do
          F^code := F^machine.genNull();
        end
    }

F ->  paro E parf #code ;
    #code {
        do
          F^code := E^code;
        end
    }
    
-- new --------------------------------------------------------------------------------------------
F -> nouveau  TYPE paro ARGS parf #code ;
    #code {
        do
          F^code := ""; -- TODO
        end
    }
    
-- this -------------------------------------------------------------------------------------------
F -> this Q #code ;
    #code {
        do
          F^code := ""; -- TODO
        end
    }
    
-- appel super ------------------------------------------------------------------------------------
F ->  super Q #code ;
    #code {
        do
          F^code := ""; -- TODO
        end
    }
    
-- acces variable ou methode ----------------------------------------------------------------------
F ->  ident Q #code ;
    #code {
        do
          F^code := ""; -- TODO
        end
    }
    
-- Q = qualificateur de variable  -----------------------------------------------------------------
Q ->  #code ;
    #code {
        do
          Q^code := "";
        end
    }
    
-- acces attribut ---------------------------------------------------------------------------------
Q ->  pt ident  Q #code ;
    #code {
        do
          Q^code := Q1^code; -- XXX
        end
    }
    
-- arguments d'appel de methode -------------------------------------------------------------------
Q ->  paro ARGS parf Q #code ;
    #code {
        do
          Q^code := Q1^code; -- XXX
        end
    }
    
ARGS ->  E ARGSX #code ;
    #code {
        do
          ARGS^code := ARGSX^code + E^code;
        end
    }
    
ARGS -> #code ;
    #code {
        do
          ARGS^code := "";
        end
    }
    
ARGSX ->   virg E ARGSX #code ;
    #code {
        do
          ARGSX^code := ARGSX1^code+ E^code;
        end
    }
    
ARGSX -> #code ;
    #code {
        do
          ARGSX^code := "";
        end
    }
    
end
